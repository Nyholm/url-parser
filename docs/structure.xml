<?xml version="1.0" encoding="utf-8"?>
<project version="2.0.0a12" title="">
  <file path="batch.php" hash="ad98e7094e175c6d317bee673f04def0" package="Default">
    <class final="false" abstract="false" namespace="codenamegary\URLParser" line="3" package="Default">
      <extends/>
      <name>Batch</name>
      <full_name>\codenamegary\URLParser\Batch</full_name>
      <property final="false" static="false" visibility="protected" line="10" namespace="codenamegary\URLParser" package="Default">
        <name>$urls</name>
        <default>array()</default>
        <docblock line="5">
          <description>The actively used URLParser\URL objects.</description>
          <long-description></long-description>
          <tag line="5" name="var" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
      </property>
      <property final="false" static="true" visibility="protected" line="18" namespace="codenamegary\URLParser" package="Default">
        <name>$instance</name>
        <default>false</default>
        <docblock line="12">
          <description>When calling methods statically the instance
is stored in this variable.</description>
          <long-description></long-description>
          <tag line="12" name="var" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
      </property>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="28" package="Default">
        <name>__construct</name>
        <full_name>__construct</full_name>
        <docblock line="20">
          <description>Base constructor, accepts a url and by default
uses the current full URL of the page being
visited.</description>
          <long-description></long-description>
          <tag line="20" name="param" description="" type="string" variable="$url">
            <type by_reference="false">string</type>
          </tag>
          <tag line="20" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="28">
          <name>$urls</name>
          <default>array()</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="protected" namespace="codenamegary\URLParser" line="36" package="Default">
        <name>_make</name>
        <full_name>_make</full_name>
      </method>
      <method final="false" abstract="false" static="false" visibility="protected" namespace="codenamegary\URLParser" line="51" package="Default">
        <name>_to</name>
        <full_name>_to</full_name>
        <docblock line="44">
          <description>Loops through the provided array and establishes new URL
objects from each URL.</description>
          <long-description></long-description>
          <tag line="44" name="param" description="" type="array" variable="$urls">
            <type by_reference="false">array</type>
          </tag>
          <tag line="44" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="51">
          <name>$urls</name>
          <default>array()</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="67" package="Default">
        <name>__callStatic</name>
        <full_name>__callStatic</full_name>
        <argument line="67">
          <name>$method</name>
          <default></default>
          <type/>
        </argument>
        <argument line="67">
          <name>$arguments</name>
          <default></default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="78" package="Default">
        <name>__call</name>
        <full_name>__call</full_name>
        <argument line="78">
          <name>$method</name>
          <default></default>
          <type/>
        </argument>
        <argument line="78">
          <name>$arguments</name>
          <default></default>
          <type/>
        </argument>
      </method>
    </class>
    <parse_markers>
      <error line="0" code="50007">No page-level DocBlock was found in file batch.php</error>
      <error line="3" code="50000">No DocBlock was found for \codenamegary\URLParser\Batch</error>
      <error line="20" code="50014">Name of argument $urls does not match with the DocBlock's name $url in __construct()</error>
      <notice line="20" code="50013">Parameter $url could not be found in __construct()</notice>
      <error line="36" code="50010">No DocBlock was found for method _make()</error>
      <error line="67" code="50010">No DocBlock was found for method __callStatic()</error>
      <error line="78" code="50010">No DocBlock was found for method __call()</error>
    </parse_markers>
  </file>
  <file path="url.php" hash="5b1e28cc9867e50fcf03e00e3ad0bbe4" package="Default">
    <class final="false" abstract="false" namespace="codenamegary\URLParser" line="3" package="Default">
      <extends/>
      <name>URL</name>
      <full_name>\codenamegary\URLParser\URL</full_name>
      <property final="false" static="false" visibility="protected" line="13" namespace="codenamegary\URLParser" package="Default">
        <name>$url</name>
        <default>array('scheme' =&gt; 'http', 'host' =&gt; '', 'port' =&gt; false, 'user' =&gt; '', 'pass' =&gt; '', 'path' =&gt; '', 'query' =&gt; '', 'fragment' =&gt; '')</default>
        <docblock line="5">
          <description>The actively used URL in the format dictated by
PHP's built-in parse_url function.</description>
          <long-description>&lt;p&gt;This is the
property which is actively used and modified
throughout the functions of this class.&lt;/p&gt;</long-description>
          <tag line="5" name="var" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
      </property>
      <property final="false" static="false" visibility="protected" line="32" namespace="codenamegary\URLParser" package="Default">
        <name>$resetURL</name>
        <default>array('scheme' =&gt; 'http', 'host' =&gt; '', 'port' =&gt; false, 'user' =&gt; '', 'pass' =&gt; '', 'path' =&gt; '', 'query' =&gt; '', 'fragment' =&gt; '')</default>
        <docblock line="24">
          <description>Same as $url but always contains a blank array,
used by the _to() method to reset the current
URL property when overwriting with a new
base URL.</description>
          <long-description></long-description>
          <tag line="24" name="var" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
      </property>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="51" package="Default">
        <name>__construct</name>
        <full_name>__construct</full_name>
        <docblock line="43">
          <description>Base constructor, accepts a url or by default
uses the current full URL of the page being
visited.</description>
          <long-description></long-description>
          <tag line="43" name="param" description="" type="string" variable="$url">
            <type by_reference="false">string</type>
          </tag>
          <tag line="43" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="51">
          <name>$url</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="protected" namespace="codenamegary\URLParser" line="65" package="Default">
        <name>currentURL</name>
        <full_name>currentURL</full_name>
        <docblock line="58">
          <description>Parses and returns the full URL of the page
currently being visited.</description>
          <long-description>&lt;p&gt;Used by the
__construct method.&lt;/p&gt;</long-description>
          <tag line="58" name="return" description="" type="string">
            <type by_reference="false">string</type>
          </tag>
        </docblock>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="86" package="Default">
        <name>to</name>
        <full_name>to</full_name>
        <docblock line="76">
          <description>Swaps the base URL the parser is operating on for the
URL passed in $url.</description>
          <long-description>&lt;p&gt;This is useful for scenarios where
you wish to batch add query strings to multiple URLs.
You can setup the queries on one object and then _to()
and _make() multiple calls to generate new URLs.&lt;/p&gt;</long-description>
          <tag line="76" name="param" description="" type="string" variable="$url">
            <type by_reference="false">string</type>
          </tag>
          <tag line="76" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="86">
          <name>$url</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="114" package="Default">
        <name>queryArray</name>
        <full_name>queryArray</full_name>
        <docblock line="95">
          <description>Returns the query string for the current URL as a $key =&gt; $value array.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com?val1=products&amp;amp;val2=services');
var_dump($url-&gt;queryArray());&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;p&gt;array(2) {
    ["val1"]=&gt;
    string(8) "products"
    ["val2"]=&gt;
    string(8) "services"
}&lt;/p&gt;</long-description>
          <tag line="95" name="return" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="143" package="Default">
        <name>query</name>
        <full_name>query</full_name>
        <docblock line="121">
          <description>Returns the query string for the current URL or, if
$query is specified returns the value for that parameter</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com?val1=products&amp;amp;val2=services');
echo $url-&gt;query('val1') . "&amp;lt;br/&gt;";
echo $url-&gt;query('val2') . "&amp;lt;br/&gt;";
echo $url-&gt;query('val3') . "&amp;lt;br/&gt;";   // Returns FALSE
echo $url-&gt;query() . "&amp;lt;br/&gt;";&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    products
    services

    val1=products&amp;amp;val2=services
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="121" name="param" description="" type="string" variable="$query">
            <type by_reference="false">string</type>
          </tag>
          <tag line="121" name="return" description="" type="string">
            <type by_reference="false">string</type>
          </tag>
        </docblock>
        <argument line="143">
          <name>$query</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="176" package="Default">
        <name>addQuery</name>
        <full_name>addQuery</full_name>
        <docblock line="156">
          <description>Appends a $key =&gt; $value array into the URL's
query string.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com');
$url-&gt;addQuery(array(
        'val1'      =&gt; 'stuff',
        'val2'      =&gt; 'more stuff',
));
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com?val1=stuff&amp;amp;val2=more+stuff
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="156" name="param" description="" type="array" variable="$query">
            <type by_reference="false">array</type>
          </tag>
          <tag line="156" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="176">
          <name>$query</name>
          <default>array()</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="199" package="Default">
        <name>stripQuery</name>
        <full_name>stripQuery</full_name>
        <docblock line="183">
          <description>Strips a query called "$query" from the query string.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com?val1=products&amp;amp;val2=services');
$url-&gt;stripQuery('val1');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com?val2=services
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="183" name="param" description="" type="string" variable="$query">
            <type by_reference="false">string</type>
          </tag>
          <tag line="183" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="199">
          <name>$query</name>
          <default></default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="223" package="Default">
        <name>stripQueries</name>
        <full_name>stripQueries</full_name>
        <docblock line="208">
          <description>Strips the ENTIRE query string from the url.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com?val1=products&amp;amp;val2=services');
$url-&gt;stripQueries();
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="208" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="246" package="Default">
        <name>swapQuery</name>
        <full_name>swapQuery</full_name>
        <docblock line="229">
          <description>Renames a query parameter from $oldName to $newName</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com?val1=products&amp;amp;val2=services');
$url-&gt;swapQuery('val1','valX');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com?val2=services&amp;amp;valX=products
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="229" name="param" description="" type="string" variable="$old">
            <type by_reference="false">string</type>
          </tag>
          <tag line="229" name="param" description="" type="string" variable="$new">
            <type by_reference="false">string</type>
          </tag>
          <tag line="229" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="246">
          <name>$oldName</name>
          <default></default>
          <type/>
        </argument>
        <argument line="246">
          <name>$newName</name>
          <default></default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="protected" namespace="codenamegary\URLParser" line="277" package="Default">
        <name>renameArrayKey</name>
        <full_name>renameArrayKey</full_name>
        <docblock line="253">
          <description>Lookups up $oldKey in $array and renames the key to $newKey</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$arr = array(
        'foo'       =&gt; 'bar',
        'foo2'      =&gt; 'bar2',
);&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;renameArrayKey( $arr, 'foo', 'test' );&lt;/p&gt;

&lt;p&gt;returns...&lt;/p&gt;

&lt;p&gt;array(
        'test'      =&gt; 'bar',
        'foo2'      =&gt; 'bar2',
)&lt;/p&gt;</long-description>
          <tag line="253" name="param" description="" type="array" variable="$array">
            <type by_reference="false">array</type>
          </tag>
          <tag line="253" name="param" description="" type="string" variable="$oldKey">
            <type by_reference="false">string</type>
          </tag>
          <tag line="253" name="param" description="" type="string" variable="$newKey">
            <type by_reference="false">string</type>
          </tag>
          <tag line="253" name="return" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
        <argument line="277">
          <name>$array</name>
          <default>array()</default>
          <type/>
        </argument>
        <argument line="277">
          <name>$oldKey</name>
          <default></default>
          <type/>
        </argument>
        <argument line="277">
          <name>$newKey</name>
          <default></default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="protected" namespace="codenamegary\URLParser" line="309" package="Default">
        <name>renameArrayKeys</name>
        <full_name>renameArrayKeys</full_name>
        <docblock line="286">
          <description>Plural of renameArrayKey, allows passing of oldKey =&gt; newKey as an array.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$arr = array(
        'foo'       =&gt; 'bar',
        'foo2'      =&gt; 'bar2',
);&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;renameArrayKey( $arr, array( 'foo' =&gt; 'test' ) );&lt;/p&gt;

&lt;p&gt;returns...&lt;/p&gt;

&lt;p&gt;array(
        'test'      =&gt; 'bar',
        'foo2'      =&gt; 'bar2',
)&lt;/p&gt;</long-description>
          <tag line="286" name="param" description="" type="array" variable="$array">
            <type by_reference="false">array</type>
          </tag>
          <tag line="286" name="param" description="" type="array" variable="$newKeys">
            <type by_reference="false">array</type>
          </tag>
          <tag line="286" name="return" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
        <argument line="309">
          <name>$array</name>
          <default>array()</default>
          <type/>
        </argument>
        <argument line="309">
          <name>$newKeys</name>
          <default></default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="333" package="Default">
        <name>segmentArray</name>
        <full_name>segmentArray</full_name>
        <docblock line="314">
          <description>Returns the segments (path) string for the current URL as an array.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/products/services');
var_dump($url-&gt;segmentArray());&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;p&gt;array(2) {
    [0]=&gt;
    string(8) "products"
    [1]=&gt;
    string(8) "services"
}&lt;/p&gt;</long-description>
          <tag line="314" name="return" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="361" package="Default">
        <name>segments</name>
        <full_name>segments</full_name>
        <docblock line="339">
          <description>Returns the the entire segment path if $search is false or
looks for $search in the URL path and returns true / false.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/products/services');
echo $url-&gt;segments('products') . "&amp;lt;br/&gt;";
echo $url-&gt;segments('services') . "&amp;lt;br/&gt;";
echo $url-&gt;segments('abcd') . "&amp;lt;br/&gt;";   // Returns FALSE
echo $url-&gt;segments() . "&amp;lt;br/&gt;";&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (true)
    (true)
    (false)
    /products/services
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="339" name="param" description="" type="string" variable="$search">
            <type by_reference="false">string</type>
          </tag>
          <tag line="339" name="return" description="" type="mixed">
            <type by_reference="false">mixed</type>
          </tag>
        </docblock>
        <argument line="361">
          <name>$search</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="protected" namespace="codenamegary\URLParser" line="573" package="Default">
        <name>sliceArrayAtKey</name>
        <full_name>sliceArrayAtKey</full_name>
        <docblock line="373">
          <description>Takes an array and returns an array of 2 arrays.</description>
          <long-description>&lt;ul&gt;
&lt;li&gt;One array including everything BEFORE the specified key&lt;/li&gt;
&lt;li&gt;Another array INCLUDING the specified key and everything AFTER&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Optionally specify "$offset" to indicate that the slice should occur AFTER
$offset keys, meaning the function will return...&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;One array including everything up to and INCLUDING the specified key
plus $offset keys later&lt;/li&gt;
&lt;li&gt;Another array including everything AFTER the specified key plus $offset keys&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the case that $key does not exist or is not specified the function will
still return 2 arrays. If $offset is not specified or is less than 0 (prepend mode),
the returned array at index 0 will contain a blank array and index 1 will contain
all of the elements from the original array. If $offset is specified and is
greater than 0 (append mode) index 0 will contain all of the elements from the
original array and index 1 will contain a blank array.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;p&gt;$arr = array(
        'key1'      =&gt; 'val1',
        'key2'      =&gt; 'val2',
        'key3'      =&gt; 'val3',
        'key4'      =&gt; 'val4',
        'key5'      =&gt; 'val5',
);&lt;/p&gt;

&lt;p&gt;Note: $offset not specificed (0) means the function operates in "prepend" mode&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;sliceArrayAtKey( $arr, 'key2' );&lt;/p&gt;

&lt;p&gt;returns....&lt;/p&gt;

&lt;p&gt;array(
        [0]         =&gt; array(
            'key1'      =&gt; 'val1',
        ),
        [1]         =&gt; array(
            'key2'      =&gt; 'val2',
        'key3'      =&gt; 'val3',
            'key4'      =&gt; 'val4',
            'key5'      =&gt; 'val5',
        ),
)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;p&gt;$arr = array(
        'key1'      =&gt; 'val1',
        'key2'      =&gt; 'val2',
        'key3'      =&gt; 'val3',
        'key4'      =&gt; 'val4',
        'key5'      =&gt; 'val5',
);&lt;/p&gt;

&lt;p&gt;Note: $offset &gt; 0 (1) means the function operates in "append" mode&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;sliceArrayAtKey( $arr, 'key2', 1 );&lt;/p&gt;

&lt;p&gt;returns....&lt;/p&gt;

&lt;p&gt;array(
        [0]         =&gt; array(
            'key1'      =&gt; 'val1',
            'key2'      =&gt; 'val2',
        ),
        [1]         =&gt; array(
        'key3'      =&gt; 'val3',
            'key4'      =&gt; 'val4',
            'key5'      =&gt; 'val5',
        ),
)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;p&gt;$arr = array(
        'key1'      =&gt; 'val1',
        'key2'      =&gt; 'val2',
        'key3'      =&gt; 'val3',
        'key4'      =&gt; 'val4',
        'key5'      =&gt; 'val5',
);&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;sliceArrayAtKey( $arr, 'key2', 3 );&lt;/p&gt;

&lt;p&gt;returns....&lt;/p&gt;

&lt;p&gt;array(
        [0]         =&gt; array(
            'key1'      =&gt; 'val1',
            'key2'      =&gt; 'val2',
            'key3'      =&gt; 'val3',
            'key4'      =&gt; 'val4',
        ),
        [1]         =&gt; array(
            'key5'      =&gt; 'val5',
        ),
)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Example 4:&lt;/p&gt;

&lt;p&gt;$arr = array(
        'key1'      =&gt; 'val1',
        'key2'      =&gt; 'val2',
        'key3'      =&gt; 'val3',
        'key4'      =&gt; 'val4',
        'key5'      =&gt; 'val5',
);&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;sliceArrayAtKey( $arr, 'key2', -1 );&lt;/p&gt;

&lt;p&gt;returns....&lt;/p&gt;

&lt;p&gt;array(
        [0]         =&gt; array(
        ),
        [1]
            'key1'      =&gt; 'val1',
            'key2'      =&gt; 'val2',
            'key3'      =&gt; 'val3',
            'key3'      =&gt; 'val4',
            'key5'      =&gt; 'val5',
        ),
)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Example 5:&lt;/p&gt;

&lt;p&gt;Note: $offset is not specified and the function defaults to "prepend" mode, $key
         does not exist.&lt;/p&gt;

&lt;p&gt;$arr = array(
        'key1'      =&gt; 'val1',
        'key2'      =&gt; 'val2',
        'key3'      =&gt; 'val3',
        'key4'      =&gt; 'val4',
        'key5'      =&gt; 'val5',
);&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;sliceArrayAtKey( $arr, 'key6' );&lt;/p&gt;

&lt;p&gt;returns....
array(
        [0]         =&gt; array(
        ),
        [1]
            'key1'      =&gt; 'val1',
            'key2'      =&gt; 'val2',
            'key3'      =&gt; 'val3',
            'key3'      =&gt; 'val4',
            'key5'      =&gt; 'val5',
        ),
)&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Example 6:&lt;/p&gt;

&lt;p&gt;Note: $offset is 1 and the function defaults to "append" mode, $key does not exist&lt;/p&gt;

&lt;p&gt;$arr = array(
        'key1'      =&gt; 'val1',
        'key2'      =&gt; 'val2',
        'key3'      =&gt; 'val3',
        'key4'      =&gt; 'val4',
        'key5'      =&gt; 'val5',
);&lt;/p&gt;

&lt;p&gt;$arr = $this-&gt;sliceArrayAtKey( $arr, 'key6', 1 );&lt;/p&gt;

&lt;p&gt;returns....
array(
        [0]         =&gt; array(
            'key1'      =&gt; 'val1',
            'key2'      =&gt; 'val2',
            'key3'      =&gt; 'val3',
            'key3'      =&gt; 'val4',
            'key5'      =&gt; 'val5',
        ),
        [1]
        ),
)&lt;/p&gt;</long-description>
          <tag line="373" name="param" description="" type="array" variable="$array">
            <type by_reference="false">array</type>
          </tag>
          <tag line="373" name="param" description="" type="string" variable="$key">
            <type by_reference="false">string</type>
          </tag>
          <tag line="373" name="param" description="" type="boolean" variable="$offset">
            <type by_reference="false">boolean</type>
          </tag>
          <tag line="373" name="return" description="" type="array">
            <type by_reference="false">array</type>
          </tag>
        </docblock>
        <argument line="573">
          <name>$array</name>
          <default></default>
          <type/>
        </argument>
        <argument line="573">
          <name>$key</name>
          <default>false</default>
          <type/>
        </argument>
        <argument line="573">
          <name>$offset</name>
          <default>0</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="protected" namespace="codenamegary\URLParser" line="688" package="Default">
        <name>insertIntoArrayAtKey</name>
        <full_name>insertIntoArrayAtKey</full_name>
        <argument line="688">
          <name>$array</name>
          <default></default>
          <type/>
        </argument>
        <argument line="688">
          <name>$key</name>
          <default></default>
          <type/>
        </argument>
        <argument line="688">
          <name>$newKeyValuePairs</name>
          <default></default>
          <type/>
        </argument>
        <argument line="688">
          <name>$offset</name>
          <default>0</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="717" package="Default">
        <name>appendSegment</name>
        <full_name>appendSegment</full_name>
        <docblock line="694">
          <description>Appends a specified text segment to the URL path.</description>
          <long-description>&lt;p&gt;Optionally
a segment can be specified ($appendAfter) and the new segment
will be inserted immediately following the instance of
$appendAfter.&lt;/p&gt;

&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/products/services');
$url-&gt;appendSegment('test');
echo $url-&gt;make() . "&amp;lt;br/&gt;";
$url-&gt;appendSegment('argh','products');
echo $url-&gt;make() . "&amp;lt;br/&gt;";&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com/products/services/test
    http://www.example.com/products/argh/services/test
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="694" name="param" description="" type="string" variable="$newSegment">
            <type by_reference="false">string</type>
          </tag>
          <tag line="694" name="param" description="" type="string" variable="$appendAfter">
            <type by_reference="false">string</type>
          </tag>
          <tag line="694" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="717">
          <name>$newSegment</name>
          <default></default>
          <type/>
        </argument>
        <argument line="717">
          <name>$appendAfter</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="747" package="Default">
        <name>prependSegment</name>
        <full_name>prependSegment</full_name>
        <docblock line="724">
          <description>Prepends a specified text segment to the URL path.</description>
          <long-description>&lt;p&gt;Optionally
a segment can be specified ($prependBefore) and the new segment
will be inserted immediately before the instance of
$prependBefore.&lt;/p&gt;

&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/products/services');
$url-&gt;prependSegment('test');
echo $url-&gt;make() . "&amp;lt;br/&gt;";
$url-&gt;prependSegment('argh','products');
echo $url-&gt;make() . "&amp;lt;br/&gt;";&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com/test/products/services
    http://www.example.com/test/argh/products/services
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="724" name="param" description="" type="string" variable="$newSegment">
            <type by_reference="false">string</type>
          </tag>
          <tag line="724" name="param" description="" type="string" variable="$prependBefore">
            <type by_reference="false">string</type>
          </tag>
          <tag line="724" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="747">
          <name>$newSegment</name>
          <default></default>
          <type/>
        </argument>
        <argument line="747">
          <name>$prependBefore</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="770" package="Default">
        <name>stripSegment</name>
        <full_name>stripSegment</full_name>
        <docblock line="754">
          <description>Strips a segment called $s from the URI.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/products/services');
$url-&gt;stripSegment('products');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com/services
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="754" name="param" description="" type="string" variable="$s">
            <type by_reference="false">string</type>
          </tag>
          <tag line="754" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="770">
          <name>$s</name>
          <default></default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="794" package="Default">
        <name>stripSegments</name>
        <full_name>stripSegments</full_name>
        <docblock line="779">
          <description>Strips all segments from the URL</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/products/services?val1=stuff&amp;amp;val2=more+stuff');
$url-&gt;stripSegments();
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com?val1=stuff&amp;amp;val2=more+stuff
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="779" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="820" package="Default">
        <name>swapSegments</name>
        <full_name>swapSegments</full_name>
        <docblock line="800">
          <description>Swaps segment names using $key =&gt; $value input where
$oldname =&gt; $newname.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/oldSegment/home');
$url-&gt;swapSegments(array(
        'oldSegment'    =&gt; 'newSegment',
        'home'          =&gt; 'main',
));
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com/newSegment/main
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="800" name="param" description="" type="array" variable="$newSegments">
            <type by_reference="false">array</type>
          </tag>
          <tag line="800" name="return" description="" type="object">
            <type by_reference="false">object</type>
          </tag>
        </docblock>
        <argument line="820">
          <name>$newSegments</name>
          <default>array()</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="843" package="Default">
        <name>anchor</name>
        <full_name>anchor</full_name>
        <docblock line="827">
          <description>Sets or returns the anchor tag at the end of the URL</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com');
$url-&gt;anchor('products');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com/#products
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="827" name="param" description="" type="string" variable="$anchor">
            <type by_reference="false">string</type>
          </tag>
          <tag line="827" name="return" description="" type="mixed">
            <type by_reference="false">mixed</type>
          </tag>
        </docblock>
        <argument line="843">
          <name>$anchor</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="866" package="Default">
        <name>protocol</name>
        <full_name>protocol</full_name>
        <docblock line="850">
          <description>Sets or returns the protocol for the URL (http/ftp/etc.).</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com');
$url-&gt;protocol('ftp');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ftp://www.example.com
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="850" name="param" description="" type="string" variable="$protocol">
            <type by_reference="false">string</type>
          </tag>
          <tag line="850" name="return" description="" type="mixed">
            <type by_reference="false">mixed</type>
          </tag>
        </docblock>
        <argument line="866">
          <name>$protocol</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="889" package="Default">
        <name>host</name>
        <full_name>host</full_name>
        <docblock line="873">
          <description>Sets or returns the host (domain) for the url.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/stuff?val1=foo');
$url-&gt;host('www.google.ca');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.google.ca/stuff?val1=foo
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="873" name="param" description="" type="string" variable="$host">
            <type by_reference="false">string</type>
          </tag>
          <tag line="873" name="return" description="" type="mixed">
            <type by_reference="false">mixed</type>
          </tag>
        </docblock>
        <argument line="889">
          <name>$host</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="912" package="Default">
        <name>port</name>
        <full_name>port</full_name>
        <docblock line="896">
          <description>Sets or returns the port for the url.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/stuff?val1=foo');
$url-&gt;port(8080);
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://www.example.com:8080/stuff?val1=foo
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="896" name="param" description="" type="string" variable="$port">
            <type by_reference="false">string</type>
          </tag>
          <tag line="896" name="return" description="" type="mixed">
            <type by_reference="false">mixed</type>
          </tag>
        </docblock>
        <argument line="912">
          <name>$port</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="935" package="Default">
        <name>user</name>
        <full_name>user</full_name>
        <docblock line="919">
          <description>Sets or returns the user for auth.</description>
          <long-description>&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/stuff?val1=foo');
$url-&gt;user('joe');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://joe@www.example.com/stuff?val1=foo
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="919" name="param" description="" type="string" variable="$user">
            <type by_reference="false">string</type>
          </tag>
          <tag line="919" name="return" description="" type="mixed">
            <type by_reference="false">mixed</type>
          </tag>
        </docblock>
        <argument line="935">
          <name>$user</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="959" package="Default">
        <name>pass</name>
        <full_name>pass</full_name>
        <docblock line="942">
          <description>Sets or returns the password for auth.</description>
          <long-description>&lt;p&gt;User must be specified first.&lt;/p&gt;

&lt;p&gt;eg...&lt;/p&gt;

&lt;p&gt;$url = new URLParser\URL('http://www.example.com/stuff?val1=foo');
$url-&gt;user('joe');
$url-&gt;pass('foobar');
echo $url-&gt;make();&lt;/p&gt;

&lt;p&gt;Outputs...&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    http://joe:foobar@www.example.com/stuff?val1=foo
&lt;/code&gt;&lt;/pre&gt;</long-description>
          <tag line="942" name="param" description="" type="string" variable="$pass">
            <type by_reference="false">string</type>
          </tag>
          <tag line="942" name="return" description="" type="mixed">
            <type by_reference="false">mixed</type>
          </tag>
        </docblock>
        <argument line="959">
          <name>$pass</name>
          <default>false</default>
          <type/>
        </argument>
      </method>
      <method final="false" abstract="false" static="false" visibility="public" namespace="codenamegary\URLParser" line="971" package="Default">
        <name>make</name>
        <full_name>make</full_name>
      </method>
      <method final="false" abstract="false" static="true" visibility="public" namespace="codenamegary\URLParser" line="995" package="Default">
        <name>__callStatic</name>
        <full_name>__callStatic</full_name>
        <argument line="995">
          <name>$method</name>
          <default></default>
          <type/>
        </argument>
        <argument line="995">
          <name>$arguments</name>
          <default></default>
          <type/>
        </argument>
      </method>
    </class>
    <parse_markers>
      <error line="0" code="50007">No page-level DocBlock was found in file url.php</error>
      <error line="3" code="50000">No DocBlock was found for \codenamegary\URLParser\URL</error>
      <error line="229" code="50014">Name of argument $oldName does not match with the DocBlock's name $old in swapQuery()</error>
      <error line="229" code="50014">Name of argument $newName does not match with the DocBlock's name $new in swapQuery()</error>
      <notice line="229" code="50013">Parameter $old could not be found in swapQuery()</notice>
      <notice line="229" code="50013">Parameter $new could not be found in swapQuery()</notice>
      <error line="688" code="50010">No DocBlock was found for method insertIntoArrayAtKey()</error>
      <error line="971" code="50010">No DocBlock was found for method make()</error>
      <error line="995" code="50010">No DocBlock was found for method __callStatic()</error>
    </parse_markers>
  </file>
  <package name="Default" full_name="Default"/>
  <namespace name="codenamegary" full_name="codenamegary">
    <namespace name="URLParser" full_name="codenamegary\URLParser"/>
  </namespace>
  <marker count="0">todo</marker>
  <marker count="0">fixme</marker>
  <deprecated count="0"/>
</project>
